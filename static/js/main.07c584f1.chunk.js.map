{"version":3,"sources":["components/Node.js","App.js","serviceWorker.js","index.js"],"names":["Node","state","nodeX","props","x","nodeY","y","color","handleClick","event","target","getParent","createLine","onDragMove","setState","name","this","onClick","draggable","onDragEnd","onMouseLeave","width","height","fill","value","stroke","fontSize","text","offsetX","offsetY","Component","App","nodes","lines","cursorX","cursorY","originalX","originalY","addingLine","getClassName","getPointerPosition","console","log","push","key","length","mouseOver","className","window","innerWidth","innerHeight","ref","stage","onMouseMove","strokeWidth","Math","random","line","points","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.07c584f1.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Circle, Label, Text } from 'react-konva';\n\nexport default class Node extends Component {\n  state = {\n    nodeX: this.props.x,\n    nodeY: this.props.y,\n    color: 'white',\n  };\n\n  static propTypes = {\n    x: PropTypes.number.isRequired,\n    y: PropTypes.number.isRequired,\n    name: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.number,\n    ]).isRequired,\n    createLine: PropTypes.func.isRequired\n  };\n\n  /**\n   * Pass up x and y values to create\n   * a new line (edge)\n   */\n  handleClick = ( event ) => {\n    // TODO:\n    //\n    // Find approach where Node\n    // has constant access to its own\n    // attributes without needing event object\n    const x = event.target.getParent().x();\n    const y = event.target.getParent().y();\n\n    this.props.createLine(x, y);\n  };\n\n  onDragMove = ( event ) => {\n    this.setState({\n      ...this.state,\n      nodeX: event.target.x(),\n      nodeY: event.target.y()\n    });\n  }\n\n  render() {\n    const { name } = this.props;\n    const { nodeX, nodeY } = this.state;\n\n    return (\n      <Label\n        x={ nodeX }\n        y={ nodeY }\n        onClick={ this.handleClick }\n        draggable={ true }\n        onDragMove={ this.onDragMove }\n        onDragEnd={ this.onDragEnd }\n        onMouseLeave={ this.onMouseLeave }\n      >\n        <Circle\n          width={ 50 }\n          height={ 50 }\n          fill={ this.state.color }\n          value={ 1 }\n          stroke=\"black\"\n        />\n        <Text\n          fontSize={ 16 }\n          text={ name }\n          fill=\"black\"\n          offsetX={ 5 }\n          offsetY={ 7 }\n        />\n      </Label>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport { Stage, Layer, Line } from 'react-konva';\nimport Node from './components/Node';\n\nexport default class App extends Component {\n  state = {\n    nodes: [], // vertices\n    lines: [], // edges,\n    cursorX: null,\n    cursorY: null,\n    originalX: null,\n    originalY: null,\n    addingLine: false,\n  };\n\n  handleClick = ( event ) => {\n    // Ignore this function from handling clicks on nodes\n    if(event.target.getClassName() !== 'Stage') {\n      if(event.target.getParent().getClassName() === 'Label' && this.state.addingLine) {\n\n        // TODO:\n        // stop tracking new line coords,\n        // save <Line /> to this.state.lines,\n        // turn off add line\n        // reset x and y values in state\n        this.setState({\n        });\n      }\n\n      return null;\n    }\n\n    // Get position\n    const { x, y } = event.target.getPointerPosition();\n    console.log(x, y);\n    let nodes = this.state.nodes;\n\n    // Add new node to list of nodes\n    nodes.push(\n      <Node\n        key={ nodes.length } \n        x={ x }\n        y={ y }\n        name={ nodes.length } \n        createLine={ this.createLine }\n      />\n    );\n\n    // Update state with list of nodes\n    this.setState({\n      ...this.state,\n      nodes: nodes\n    });\n  }\n\n  /**\n   * Creates a line from an originating\n   * x and y to the cursor\n   *\n   * @param Number x\n   * @param Number y\n   */\n  createLine = ( x, y ) => {\n    this.setState({\n      ...this.state,\n      addingLine: true,\n      originalX: x,\n      originalY: y\n    });\n  }\n\n  /**\n   * On mouse move on stage, update cursor x and y\n   */\n  mouseOver = (event) => {\n    if (event.target.getClassName() !== 'Stage') {\n      return null;\n    }\n\n    const { x, y } = event.target.getPointerPosition();\n\n    this.setState({\n      ...this.state,\n      cursorX: x,\n      cursorY: y\n    });\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <h1>Click to create a node:</h1>\n        <Stage\n          width={ window.innerWidth }\n          height={ window.innerHeight }\n          onClick={ this.handleClick }\n          ref={ ref => ( this.stage = ref ) }\n          onMouseMove={ this.mouseOver }\n        >\n          <Layer>\n            { this.state.nodes }\n          </Layer>\n          <Layer>\n            { this.state.lines }\n            { this.state.addingLine ?\n                <Line \n                  stroke=\"black\"\n                  strokeWidth={ 5 }\n                  draggable={ true }\n                  key={Math.random()}\n                  ref={ ref => ( this.line = ref ) }\n                  points={[\n                    this.state.originalX, this.state.originalY, this.state.cursorX, this.state.cursorY \n                  ]}\n                />\n                : null\n            }\n          </Layer>\n        </Stage>\n      </div>\n    );\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}